## Порождающие (или Шаблоны)
[Порождающие паттерны](https://doka.guide/tools/design-patterns-creational/) помогают решать задачи с созданием сущностей или групп похожих сущностей. Они убирают лишнее дублирование, делают процесс создания объектов короче и прямолинейнее.  
Среди порождающих паттернов мы можем выделить:

### Синглтон, или Одиночка
Здесь рассмотрим первый пораждающий фактор – `Singleton`.  
> Это Объект, который есть в системе в одном экземпляре, к нему есть какая-то глобальная точка доступа, и к которому есть доступ из разных частей программы.  
> И только в этом случае стоит использовать этот поррождающий паттерн.  

Для реализации такого паттерна можно привести примеры:  
– в интернет-магазине – это корзина, или карта клиента  
– мультимедийная система – это может быть инстанс плэйера  
– ...

#### Создание Singleton при помощи литерала объекта

В JS объекты никода не будут равны.
```javascript
const instance1 = {
  name: 'songleton'
};

const instance2 = {
  name: 'singleton'
}

instance1 === instance2 // false
{} === {}               // false
```
Поэтому можно сделать вывод, что всякий раз, когда мы создаём объект при помощи литерала, то у нас получается `Singleton`, или Объект в единственном экземпляре.  

Создавать объекты можно не только при помощи литерала, но при помощи конструктора `new`.  
Для того, чтобы создать Singleton, сузествует два основных подхода:  
1. можно создать глобальную переменную и обращаться к ней, после чего весь код завернуть в модуль  
2. определить `Singleton` внутри объекта  

*Варинт 1*  
Внутри класса реализован пользовательский конструктор, который проверяет, существует ли instance. И если его нет, то он создаёт его и начинает на него ссылаться.  
Если же он есть, то `constructor` получает ссылку на него.  
В результате этого в системе появляется объект `instance` и конструктор со ссылкой на этот объект. И теперь любой объект, созданный при помощи конструктора Counter, будет получать ссылку на instance.  
```javascript
let instance;

class Counter {
  constructor() {
    if(!instance) instance = this;
    return instance;
  }
}
```
Немного ращирим этот класс:
```javascript
let instance;
class Counter {
  constructor() {
    if (!instance) instance = this;
    instance.count = 0;
    return instance;
  }

  getCount() {
    return instance.count;
  }

  increseCount() {
    return instance.count++;
  }
};

const myCount1 = new Counter();
const myCount2 = new Counter();

myCount1.increseCount();
myCount1.increseCount();
myCount2.increseCount();
myCount2.increseCount();

myCount2.getCount()
console.log('myCount2.getCount(): ', myCount2.getCount());
myCount1.getCount()
console.log('myCount1.getCount(): ', myCount1.getCount());
```  

Наличие глобальной переменной `let instance;` – не только плохой тон, но и существует вероятность, что можно случайно эту переменную переопределить.  
Поэтому перепишем код так:  
```javascript
class Counter {
  constructor() {
    if (typeof Counter.instance === 'object') {
      return Counter.instance;
    }
    this.count = 0;
    Counter.instance = this;
    return this;
  }

  getCount() {
    return this.count;
  }

  increseCount() {
    return this.count++;
  }
};
```  

Синглтон, или одиночка, (англ. singleton) — это шаблон, который позволяет создать лишь один объект, а при попытке создать новый возвращает уже созданный.  

> Синглтон может нарушать принцип открытости и закрытости, увеличивая зацепление объектов. Из-за этого иногда его считают *антипаттерном*.  
*Пример:*  
```javascript
class Sun {
  // Держим ссылку на созданный объект:
  static instance = null

  // Делаем конструктор приватным:
  #constructor() {}

  static get instance() {
    // Если объект был создан ранее, возвращаем его:
    if (this.instance) return this.instance

    // Иначе создаём новый экземпляр:
    this.instance = new this()
    return this.instance
  }
}
```  
Использовать такой синглтон мы тогда будем так:

```javascript
// При первом вызове создастся новый объект:
const sun = Sun.instance

// В дальнейшем instance будет возвращать
// ранее созданный объект:
const sun1 = Sun.instance
const sun2 = Sun.instance

console.log(sun === sun1)
// true
console.log(sun === sun2)
// true
```  
Важно, что нам приходится прятать конструктор от внешнего мира, чтобы нельзя было создать новый экземпляр класса извне. И в целом код синглтона выглядит не очень опрятным.  
### Когда использовать?  
Когда требуется обеспечить строго один экземпляр объекта на всё приложение. Чаще всего это не нужно.  
Перед использованием синглтона стоит подумать об изменении дизайна программы, чтобы нужды использовать синглтон не было.

### «Фабрика»
> Фабрика (англ. factory) создаёт объект, избавляя нас от необходимости знать детали создания.
> Например, если нам нужна гитара, мы можем выпилить деку, самостоятельно сделать струны из никеля, склеить корпус, сделать гриф, расставить лады и натянуть струны...  
> А можем сходить в магазин и взять гитару, созданную на фабрике — в этом случае нам уже не требуется знать, что именно надо сделать, чтобы гитару создать.  

*Пример:*  
Фабрика в программировании принимает от нас сигнал, что надо создать объект, и создаёт его, инкапсулируя логику создания внутри себя.
```javascript
function createGuitar(stringsCount = 6) {
  return {
    strings: stringsCount,
    frets: 24,
    fretBoardMaterial: 'кедр',
    boardMaterial: 'клён',
  }
}
```  
В примере мы возвращаем объект гитары из функции-фабрики `createGuitar()`. Функция принимает количество струн как аргумент и подставляет его в качестве значения для поля `strings`. Все остальные поля она заполняет самостоятельно.

Нам в этом примере не требуется знать, как именно должно называться поле, описывающее количество струн, мы лишь передаём его в качестве аргумента. Получать объект гитары в этом случае мы будем так:  
```javascript
const sixStringsGuitar = createGuitar(6);
const sevenStringsGuitar = createGuitar(7);
```
### «Фабричный метод»
Исходный класс можно называть – `супер Классом`.  

Фабрику можно использовать в случае, когда необходимо создавать множество однотипных объектов, то есть объекты с одинаковой структурой, но разными данными, при этом такие объекты могут содержать как свойства, так и методы.  

Простая "фабрика" может состоять из двух классов:
– класса конструктора, который генерирует этот объект,  
– и класса, который вызывает это создание с определёнными параметрами.  
Рассмотрим стандартный класс-коструктор:  
```javascript
class Bmw {
  constructor(model, price, maxSpeed) {
    this.model = model;
    this.price = price;
    this.maxSpeed = maxSpeed;
  }
}
```  
Но в тоже время, над этим классом-конструктором, будет надстройка из "фабрики":  
```javascript
class BmwFactory {
  constructor(type) {
    if(type === 'X5') return new Bmw(type, 108000, 300)
    if(type === 'X6') return new Bmw(type, 111000, 320)
  }
}

const factory = new BmwFactory();

const x5 = factory.create('X5')
const x6 = factory.create('X6')
```  
***Минусы такого подхода***  
При большом количестве создаваемых объектов, структура нашего фабричного метода начнёт разрастаться, и в этом случае эту проблему поможет решить шаблон "абстрактной фабрики".  

### «Абстрактная фабрика»
> Абстрактная фабрика (англ. abstract factory) — это фабрика фабрик  
> Этот шаблон группирует связанные или похожие фабрики объектов вместе, позволяя выбирать нужную в зависимости от ситуации.  
> Абстрактная фабрика не возвращает конкретный объект, вместо этого она описывает тип объекта, который будет создан.  

Другими словами можно сказать ещё так: это паттерн, который создаёт интерфейс группирующий другие "фабрики", которыые логически связаны друг с другом.  
Условно говоря – это своеобразная абстракция для "фабрики" и "фабричного метода".   

```javascript
// Abstract factory
function bmwProducer(type) {
  return type === 'sport' ? sportCarFactory : familyCarFactory;
}

// Factories:
function sportCarFactory() {
  return new Z4();
}
function familyCarFactory() {
  return new I3();
}

class Z4 {
  info() {
    return 'Z4 is a Sport car';
  }
}
class I3 {
  info() {
    return 'I3 is a Family car';
  }
}

// Initializing Abstract Factory to produce certain type:
const produce = bmwProducer('sport');

// Car producing factory:
const myCar = new produce();
console.log('myCar: ', myCar.info());
```  

### Прототип
Это порождающий паттерн, который позволяет копировать объекты, не вдаваясь в подробности их реализации.  
С одной стороны, это немного похожу на "фабрику", но в действительности посыл здесь другой, – в шаблоне `Прототип` у нас есть базовая реализация Класса. И используя упрощёный интерфейс, мы создаём клоны Объектов.  
А клоны могут понадобиться для того, чтобы в случае необходимости, изменить их струтуру, и заточить под выполнение определённой задачи.  
Сам класс Прототипа выгляит так:  
```javascript
class TeslaCar {
  constructor(model, price, interior, autopilot) {
    this.model = model;
    this.price = price;
    this.interior = interior;
    this.autopilot = autopilot;
  }

  produce() {
    return new TeslaCar(this.model, this.price, this.interior, this.autopilot);
  }
}
```  
Здесь мы создали класс `TeslaCar`, где опредилили все основные характеристики будущегоо автомобиля. Фактически, это можно назвать "Технической документацией автомобиля". В ней мы опредилили некторые параметры: модель, цвет, цену, наличие автопилота.  
После чего, на основании этой "документации", мы создаём прототип автомобиля `prototypeCar`.  
```javascript
// Produce base vehicle:
const prototypeCar = new TeslaCar('S', 80000, 'black', false);

// Cloning base vehicle:
const car1 = prototypeCar.produce();
const car2 = prototypeCar.produce();
const car3 = prototypeCar.produce();

// Add changes for particular vehicle:
car1.interior = 'white';
car1.autopilot = true;
```  
**Итог**  
Prototype - это паттерн, при помощи которого можно создать копию Объекта везде, где это требуется с минимальными затратами памяти, так как создаётся копия на основании уже существующей структуры, и в случае необходимости, возможно модифицировать каждый экземпляр точечно под опоределённые нужны, нне меняя базовой структуры.  

### «Строитель»
> Билдер, или строитель, (англ. builder) позволяет создавать объекты, добавляя им свойства по заданным правилам. Он полезен, когда при создании объекта нужно выполнить много шагов, часть из которых могут быть необязательными.  
Этот паттерн используется для создания объектов со сложными состояниями.  
Так же он может иметь дополнительный слой абстракций – **Директор**, который управляет несколькими строителями.  

Создание объектов с определёнными значениями, инициализируется в конструкторе. В нём могут задаваться различные свойства будущего объекта. Но, если такой процесс усложняется, и свойства начинают зависить от различных факторов, и добавляться они могут в зависимости от различных условий, то **Конструктор класса** может разрастись до невероятных размеров.  

Чтобы такого не произошло, и используется паттерн `Builder`.  
*Пример 1:*  
Напишем "строителя" автомобиля, а затем будем вносить в него изменения конфигурации:
```javascript
class Car {
  constructor() {
    this.autoPilot = false;
    this.parktronic = false;
    this.alarm = false;
  }
}

class CarBuilder {
  constructor() {
    this.car = new Car();
  }
  addAutoPilot(autoPilot) {
    this.car.autoPilot = autoPilot;
    return this;
  }
  addParktronic(parktronic) {
    this.car.parktronic = parktronic;
    return this;
  }
  addAlarm(alarm) {
    this.car.alarm = alarm;
    return this;
  }
  updateEngine(engine) {
    this.car.engine = engine;
    return this;
  }
  build() {
    return this.car
  }
};

const myCar = new CarBuilder()
  .addAutoPilot(true)
  .addParktronic(true)
  .updateEngine('V8')
  .build();
console.log('myCar: ', myCar);

const myNewCar = new CarBuilder()
  .addAlarm(true)
  .updateEngine('V6')
  .build();
console.log('myNewCar: ', myNewCar);
```  
---
*Пример 2:*  
Допустим, мы пишем конструктор кофейных напитков. Все они готовятся на основе эспрессо, но может быть много дополнительных ингредиентов.

```javascript 
class Drink {
  constructor(settings) {
    const { base, milk, sugar, cream } = settings

    this.base = base
    this.milk = milk
    this.sugar = sugar
    this.cream = cream
  }
}
```  
Мы можем добавить молоко, сахар и сливки.  
Чтобы было удобно создавать объекты напитков, мы будем указывать билдеру шаг за шагом — что добавить к кофе:  
```javascript
class DrinkBuilder {
  settings = {
    base: 'espresso',
  }

  addMilk = () => {
    this.settings.milk = true
    return this
  }

  addSugar = () => {
    this.settings.sugar = true
    return this
  }

  addCream = () => {
    this.settings.cream = true
    return this
  }

  addSyrup = () => {
    this.settings.syrup = true
    return this
  }

  build = () => new Drink(this.settings)
}
```  
По умолчанию в настройки мы добавляем только эспрессо, но при вызове методов `add...()` добавляем в настройки новый ингредиент.  
При вызове `build()` возвращаем собранный напиток:  
```javascript
const latte = new DrinkBuilder().addMilk().build()
const withSugarAndCream = new DrinkBuilder().addSugar().addCream().build()
```  
Обратите внимание, что мы можем собирать методы `add...()` в цепочку, завершая вызовом `build()`. Это возможно потому, что каждый из `add...()`-методов возвращает текущий **экземпляр** билдера.  
#### Когда использовать?
Если в приложении требуется создавать объекты с разными особенностями, или процесс создания объекта делится на отдельные шаги, то билдер помогает не засорять код условиями и проверками.  

#### Итог:
Этот паттерн, в очень удобной форме, позволяет создавать различные конфигурации Объектов, не засоряя исходный конструктор дополнительной логикой, которая в нём, фактически не нужна.  
Такой шаблон проектирования нужен, если обёект существует в разных вариациях, или процесс инстанцирования состояит из нескольких шагов.  